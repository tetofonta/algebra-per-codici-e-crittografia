\subsection{Attacchi}
\subsubsection{Genuine Reader}
\begin{frame}
    \frametitle{LFSR Recovery (Genuine Reader Attack)}
    Data la dimensione ridotta del LFSR è possibile creare una tabella contenente le coppie ($LFSR_{value}$, $KeyStream$) per tutti gli stati da \texttt{0x000000000000} a \texttt{0x000FFFFFFFFF} ($2^{36}$ righe)\pause

    Successivamente si effettua un tentativo di autenticazione simulando un tag, inviando all'inizio dela trasmissione un nonce $n_t$ nella forma \texttt{0x0000XXX0} (4096 tentativi) senza procedere oltre al primo passaggio\pause
    
    Questo causa l'invio di un comando di halt da parte del lettore (comando noto) cifrato con lo stato attuale dal quale possiamo ricavare $ks_3$ e $ks_2$ dalla risposta $suc^2(n_t)$
\end{frame}
\note{
    Come è possibile osservare dalla figura \ref{fig:crypto1} la funzione f non dipende dai valori terminali del LFSR.
    
}
\begin{frame}
    \frametitle{LFSR Recovery (Genuine Reader Attack)}
    Data la struttura è stato notato come esista un valore di $n_t$ tale per cui lo stato del LFSR equivale a \[\texttt{0xYYYYYYYY000Y}\]\pause

    Il lettore quindi aggiorna il cifrario con il valore di $n_r$, che causa gli zeri nel LFSR di raggiungere lo stato \[\texttt{0x000YZZZZZZZZ}\]\pause

    Possiamo quindi trovare lo stato del LFSR dalla tabella cercando per i valori di $ks_2$ e $ks_3$
\end{frame}

\begin{frame}
    \frametitle{LFSR Rollback (Genuine Reader Attack)}
    Dato un qualsivoglia stato del LFSR è possibile ottenere lo stato dell'iterazione precedente conoscendo quanto è stato inserio.
    \pause

    Una volta ottenuto lo stato del LFSR dopo l'inserzione del nonce $n_r$ non è ancora possibile effettuare il rollback perchè $n_r$ è cifrato.
    \pause
    
    La vulnerabilità viene utilizzata ora: Dato che l'MSB del LFSR non è input della funzione di filtro $f$ (Vedi figura~\ref{fig:crypto1})
    è possibile sostituirlo con un valore $r$ senza effetti collaterali.
    \pause
    
    Ciò permette di ottenere il $n_{r31}$.
    Utilizzando questo valore è quindi possibile ricalcolare il valore di $r$
\end{frame}
\note{
    vedi \cite{garcia2008dismantling},
    la relazione è \[rk+48 = rk \oplus rk+5 \oplus rk+9 \oplus rk+10 \oplus rk+12 \oplus rk+14 \oplus rk+15 \oplus \]\[rk+17 \oplus rk+19 \oplus rk+24 \oplus rk+27 \oplus rk+29 \oplus rk+35 \oplus rk+39 \oplus rk+41 \oplus rk+42 \oplus rk+43 \oplus i.\]
}

\subsubsection{Genuine Tag}
\begin{frame}
    \frametitle{Genuine Tag Attack}
    Sfruttando la vulnerabità relativa al leak di informazioni all'invio di un NACK~\ref{sec:parity-bit-vuln} è possibile utilizzarla al fine di ottenere 
    la chiave utilizzata dal tag.\pause

    Ottenendo il NACK cifrato è possibile ottenere 4 bit di keystream.\pause

    \textit{Fissando un nonce $n_t$ e un prefisso di 24 bit sulla risposta alla challenge $a_t$ che ha dato un NACK, esiste una probabilità di 1/12.8 che il keystream non dipenda dal quarto byte decifrato.}\cite{Courtois2009TheDS}
\end{frame}

\begin{frame}
    \frametitle{Genuine Tag Attack}
    A questo punto è possibile sfruttare il fatto che l'RNG sia predicibile in funzione del Power On Time:
    Mantenendo $n_t$ costante insieme ai primi 24 bit della risposta ritentiamo l'autenticazione per 256 volte 
    (variando quindi il quarto byte della risposta) ottenendo così circa 8 risposte da parte del tag.\pause

    A queso punto è dimostrabile che, assumendo che il keystream non dipenda dalla decifratura del quarto byte (P = 1/12.8), allora
    la differenza degli stati dipende da una funzione della differenza di c3\cite{Courtois2009TheDS}\pause

    Con queste risposte è possibile clcolare la differenza dello stato per tutti i tentativi
\end{frame}

\begin{frame}
    \frametitle{Genuine Tag Attack}
    A questo punto è necessario individuare i 21 bit dello stato che determineranno i bit a seguire, dove per ogni risposta del tag
    potremo dividere la dimensione dello spazio di ricerca di 4.\pause

    Seppur un attacco complesso e basato su proprietà sttistiche, è possibile ottenere la chiave di autenticazione a un settore in circa 4000 query (30 minuti)\pause

    È possibile trovare una implementazione qui: \href{https://github.com/DrSchottky/mfcuk/blob/master/src/mfcuk.c\#L623}{https://github.com/DrSchottky/mfcuk/}
\end{frame}

\subsubsection{Nested Authentication}
\begin{frame}
    \frametitle{Nested authentication}\label{sec:nested-auth}
    Autenticazioni successive seguono lo stesso protocollo ma $n_t$ viene inviato cifrato con il nuovo stato derivato dalla chiave di autenticazione
    caricata nel LFSR\pause

    Un possibile attacco potrebbe essere il bruteforcing dei 65536 possibili valori casuali\pause

    Utilizzando la vulnerabilità dove i bit di parità sono cifrati con un bit condiviso del keystream (Slide~\ref{sec:parity-enc}) possiamo dedurre che
    \[n_t = {b_{31},b_{30}, ... b_1, b_0}\]
    \begin{multline*}
        transmission_stream = \{b_0, b_1 ... b_7, p_0, b_8 ... b_{15}, p_1, \\ b_{16} ... b_{23}, p_2, b_{24} ... b_{31}, p_3\}
    \end{multline*}

\end{frame}

\begin{frame}
    \frametitle{Nested authentication}
    Dalla precedente vale
    \begin{math}
        \begin{cases}
            p_0 = rp_0 \oplus ks_8\\
            b_8 = rb_8 \oplus ks_8\\
            p_1 = rp_1 \oplus ks_{16}\\
            b_{16} = rb_{16} \oplus ks_{16}\\
            p_2 = rp_2 \oplus ks_{24}\\
            b_{24} = rb_{24} \oplus ks_{24}\\
        \end{cases}
    \end{math}
\end{frame}

\begin{frame}
    \frametitle{Nested authentication}
    Dalla quale possiamo dedurre
    \begin{math}
        \begin{cases}
            p_0 \oplus b_8 = rb_8 \oplus rp_0\\
            p_1 \oplus b_{16} = rb_{16} \oplus rp_1\\
            p_2 \oplus b_{24} = rb_{24} \oplus rp_2\\
        \end{cases}
    \end{math}\pause

    Di conseguenza è possibile ricavare se il bit di parità del byte precedente è uguale al primo bit del secondo byte, dimezzando lo spazio di ricerca
    per ogni bit di parità (per un totale di una riduzione di un fattore pari a 8)\pause

    Nel caso di una comunicazione tra lettore e tag genuini è possibile ridurre lo spazio di ricerca ulteriormente grazie alla successiva risposta del tag contenente 7 bit di parità,
    portando così i nonce candidati a 64.
\end{frame}
\note{
    addizionalmente è possibile prevedere il valore del nonce data la bassa entropia del rng e la sua predicibilità
}